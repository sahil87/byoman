#!/usr/bin/env bash
#
# wt-merge - Merge PR and cleanup worktree
#
# Usage: wt-merge [OPTIONS]
#        wt-merge help
#
# Merges the PR for the current branch and optionally cleans up worktree

set -euo pipefail

# ============================================================================
# Constants
# ============================================================================

# Exit codes per contracts/cli-interface.md
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_INVALID_ARGS=2
readonly EXIT_GIT_ERROR=3

# Colors (disabled if NO_COLOR is set)
if [[ -z "${NO_COLOR:-}" ]]; then
    readonly RED=$'\033[0;31m'
    readonly YELLOW=$'\033[0;33m'
    readonly GREEN=$'\033[0;32m'
    # shellcheck disable=SC2034 # Used in display functions
    readonly CYAN=$'\033[0;36m'
    readonly BOLD=$'\033[1m'
    readonly RESET=$'\033[0m'
    readonly CHECK=$'\xE2\x9C\x93'  # ✓
    readonly CROSS=$'\xE2\x9C\x97'  # ✗
else
    readonly RED=''
    readonly YELLOW=''
    readonly GREEN=''
    # shellcheck disable=SC2034 # Used in display functions
    readonly CYAN=''
    readonly BOLD=''
    readonly RESET=''
    readonly CHECK='[OK]'
    readonly CROSS='[FAIL]'
fi

# ============================================================================
# Error Handling (Constitution III compliant - what/why/fix format)
# ============================================================================

error() {
    local what="$1"
    local why="$2"
    local fix="${3:-}"

    echo "${RED}Error:${RESET} $what" >&2
    echo "  ${BOLD}Why:${RESET} $why" >&2
    if [[ -n "$fix" ]]; then
        echo "  ${BOLD}Fix:${RESET} $fix" >&2
    fi
    exit "$EXIT_GENERAL_ERROR"
}

error_with_code() {
    local code="$1"
    local what="$2"
    local why="$3"
    local fix="${4:-}"

    echo "${RED}Error:${RESET} $what" >&2
    echo "  ${BOLD}Why:${RESET} $why" >&2
    if [[ -n "$fix" ]]; then
        echo "  ${BOLD}Fix:${RESET} $fix" >&2
    fi
    exit "$code"
}

# ============================================================================
# Menu Helper
# ============================================================================

show_menu() {
    local prompt="$1"
    shift
    local options=("$@")

    echo "$prompt"
    local i=1
    for opt in "${options[@]}"; do
        echo "  ${BOLD}$i)${RESET} $opt"
        ((i++))
    done
    echo "  ${BOLD}0)${RESET} Cancel"
    echo ""

    while true; do
        printf "Choice: "
        read -r choice

        if [[ -z "$choice" ]]; then
            MENU_CHOICE=0
            return 0
        fi

        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo "Invalid choice. Please enter a number."
            continue
        fi

        if ((choice < 0 || choice > ${#options[@]})); then
            echo "Invalid choice. Please enter a number between 0 and ${#options[@]}."
            continue
        fi

        MENU_CHOICE="$choice"
        return 0
    done
}

# ============================================================================
# Git Repository Detection
# ============================================================================

validate_git_repo() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        error_with_code "$EXIT_GENERAL_ERROR" \
            "Not a git repository" \
            "wt-merge requires a git repository" \
            "Navigate to a git repository and try again"
    fi
}

# Check for uncommitted changes (staged or unstaged)
has_uncommitted_changes() {
    ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null
}

require_clean_worktree() {
    if has_uncommitted_changes; then
        error "Uncommitted changes detected" \
            "All changes must be committed before proceeding" \
            "Commit your changes first: git commit -am 'message' or use /changes:commit"
    fi
}

# Check if we're inside a worktree (not the main repo)
is_worktree() {
    local git_dir common_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null)
    common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
    [[ "$git_dir" != "$common_dir" ]]
}

# Get the main repository root path
get_main_repo_root() {
    local common_dir
    common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
    echo "${common_dir%/.git}"
}

# Get the worktrees directory path
get_worktrees_dir() {
    local main_repo
    main_repo=$(get_main_repo_root)
    local repo_name
    repo_name=$(basename "$main_repo")
    echo "$(dirname "$main_repo")/${repo_name}-worktrees"
}

# Get current worktree info
get_current_worktree_info() {
    if ! is_worktree; then
        return 1
    fi

    WT_PATH=$(git rev-parse --show-toplevel 2>/dev/null)
    WT_NAME=$(basename "$WT_PATH")
    WT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
}

# ============================================================================
# Cross-Platform Helpers
# ============================================================================

detect_os() {
    case "$(uname -s)" in
        Darwin) echo "macos" ;;
        Linux)  echo "linux" ;;
        *)      echo "unknown" ;;
    esac
}

open_url() {
    local url="$1"
    local os
    os=$(detect_os)

    case "$os" in
        macos)
            open "$url"
            ;;
        linux)
            xdg-open "$url" &>/dev/null &
            ;;
        *)
            echo "Please open: $url"
            ;;
    esac
}

# ============================================================================
# GitHub CLI Detection
# ============================================================================

has_gh_cli() {
    command -v gh &>/dev/null && gh auth status &>/dev/null
}

require_gh_cli() {
    if ! has_gh_cli; then
        error "gh CLI required for merging" \
            "wt-merge uses the GitHub API via gh to merge PRs" \
            "Install gh CLI: brew install gh (macOS) or apt install gh (Linux)"
    fi
}

# ============================================================================
# Branch Operations
# ============================================================================

get_current_branch() {
    git rev-parse --abbrev-ref HEAD 2>/dev/null
}

# Delete local branch
delete_local_branch() {
    local branch="$1"
    git branch -D "$branch" 2>/dev/null
}

# Delete remote branch
delete_remote_branch() {
    local branch="$1"
    git push origin --delete "$branch" 2>/dev/null
}

# Check if branch exists on remote
branch_on_remote() {
    local branch="$1"
    git ls-remote --heads origin "$branch" 2>/dev/null | grep -q "$branch"
}

# ============================================================================
# Worktree Operations
# ============================================================================

remove_worktree() {
    local wt_path="$1"
    git worktree remove --force "$wt_path" 2>/dev/null
}

# ============================================================================
# PR Status and Merge
# ============================================================================

# Get comprehensive PR status
# Returns: JSON with PR info
get_pr_status() {
    gh pr view --json number,title,state,mergeable,mergeStateStatus,statusCheckRollup,reviewDecision,url 2>/dev/null
}

# Parse PR status for display
# Sets: PR_NUMBER, PR_TITLE, PR_STATE, PR_MERGEABLE, PR_MERGE_STATUS, PR_REVIEW, PR_URL, PR_CHECKS_PASS, PR_CHECKS_FAIL
parse_pr_status() {
    local json="$1"

    PR_NUMBER=$(echo "$json" | jq -r '.number')
    PR_TITLE=$(echo "$json" | jq -r '.title')
    PR_STATE=$(echo "$json" | jq -r '.state')
    PR_MERGEABLE=$(echo "$json" | jq -r '.mergeable')
    PR_MERGE_STATUS=$(echo "$json" | jq -r '.mergeStateStatus')
    PR_REVIEW=$(echo "$json" | jq -r '.reviewDecision // "NONE"')
    PR_URL=$(echo "$json" | jq -r '.url')

    # Count check statuses
    PR_CHECKS_PASS=$(echo "$json" | jq '[.statusCheckRollup[]? | select(.conclusion == "SUCCESS")] | length')
    PR_CHECKS_FAIL=$(echo "$json" | jq '[.statusCheckRollup[]? | select(.conclusion == "FAILURE")] | length')
    PR_CHECKS_PENDING=$(echo "$json" | jq '[.statusCheckRollup[]? | select(.conclusion == null or .conclusion == "PENDING")] | length')
}

# Display PR status
display_pr_status() {
    echo "PR #${BOLD}$PR_NUMBER${RESET}: $PR_TITLE"
    echo ""
    echo "Status: $PR_STATE"

    # Checks
    local checks_str=""
    if [[ "$PR_CHECKS_FAIL" -gt 0 ]]; then
        checks_str="${RED}${CROSS}${RESET} $PR_CHECKS_FAIL failed"
        if [[ "$PR_CHECKS_PASS" -gt 0 ]]; then
            checks_str="$checks_str, ${GREEN}${CHECK}${RESET} $PR_CHECKS_PASS passed"
        fi
    elif [[ "$PR_CHECKS_PENDING" -gt 0 ]]; then
        checks_str="${YELLOW}...${RESET} $PR_CHECKS_PENDING pending"
        if [[ "$PR_CHECKS_PASS" -gt 0 ]]; then
            checks_str="$checks_str, ${GREEN}${CHECK}${RESET} $PR_CHECKS_PASS passed"
        fi
    elif [[ "$PR_CHECKS_PASS" -gt 0 ]]; then
        checks_str="${GREEN}${CHECK}${RESET} $PR_CHECKS_PASS passed"
    else
        checks_str="No checks"
    fi
    echo "Checks: $checks_str"

    # Review
    local review_str
    case "$PR_REVIEW" in
        APPROVED)
            review_str="${GREEN}Approved${RESET}"
            ;;
        CHANGES_REQUESTED)
            review_str="${RED}Changes requested${RESET}"
            ;;
        REVIEW_REQUIRED)
            review_str="${YELLOW}Review required${RESET}"
            ;;
        *)
            review_str="No review required"
            ;;
    esac
    echo "Review: $review_str"

    # Mergeable
    local merge_str
    case "$PR_MERGE_STATUS" in
        CLEAN)
            merge_str="${GREEN}Yes${RESET}"
            ;;
        BLOCKED)
            merge_str="${RED}Blocked${RESET}"
            ;;
        DIRTY)
            merge_str="${RED}Has conflicts${RESET}"
            ;;
        UNSTABLE)
            merge_str="${YELLOW}Unstable (checks failing)${RESET}"
            ;;
        *)
            merge_str="$PR_MERGE_STATUS"
            ;;
    esac
    echo "Mergeable: $merge_str"
    echo ""
}

# Check if PR can be merged
can_merge_pr() {
    [[ "$PR_MERGEABLE" == "MERGEABLE" ]] && [[ "$PR_MERGE_STATUS" == "CLEAN" || "$PR_MERGE_STATUS" == "UNSTABLE" ]]
}

# Merge PR
merge_pr() {
    local delete_branch="${1:-}"

    echo "Merging PR #$PR_NUMBER..."

    local flags=""
    if [[ "$delete_branch" == "delete" ]]; then
        flags="--delete-branch"
    fi

    # shellcheck disable=SC2086
    if gh pr merge $flags 2>/dev/null; then
        echo ""
        echo "${GREEN}PR merged successfully!${RESET}"
        return 0
    else
        error_with_code "$EXIT_GIT_ERROR" \
            "Failed to merge PR" \
            "gh pr merge failed" \
            "Check PR status and try again"
    fi
}

# Handle no PR found
handle_no_pr() {
    local current_branch="$1"

    echo "${RED}Error:${RESET} No PR found for branch $current_branch" >&2
    echo "  ${BOLD}Why:${RESET} A pull request must exist before merging" >&2
    echo "  ${BOLD}Fix:${RESET} Run 'wt-pr' first to create a PR" >&2
    echo ""

    show_menu "Create PR now?" \
        "Create draft PR" \
        "Create ready PR"

    case "$MENU_CHOICE" in
        1)
            gh pr create --draft --fill
            exit "$EXIT_SUCCESS"
            ;;
        2)
            gh pr create --fill
            exit "$EXIT_SUCCESS"
            ;;
        0)
            exit "$EXIT_GENERAL_ERROR"
            ;;
    esac
}

# Handle checks failing
handle_checks_failing() {
    echo ""
    echo "${YELLOW}Warning:${RESET} PR has failing checks"
    echo ""

    # Show failing checks
    gh pr view --json statusCheckRollup --jq '.statusCheckRollup[] | select(.conclusion == "FAILURE") | "  \(.context // .name): \(.conclusion)"' 2>/dev/null

    echo ""
    show_menu "What would you like to do?" \
        "Wait for checks (refresh status)" \
        "Merge anyway (if permitted)"

    case "$MENU_CHOICE" in
        1)
            echo "Refreshing status..."
            main_merge_flow
            ;;
        2)
            merge_pr
            ;;
        0)
            echo "Cancelled."
            exit "$EXIT_SUCCESS"
            ;;
    esac
}

# Handle not approved
handle_not_approved() {
    echo ""
    echo "${YELLOW}Warning:${RESET} PR is not approved"
    echo ""

    show_menu "What would you like to do?" \
        "Open PR in browser (to address feedback)"

    case "$MENU_CHOICE" in
        1)
            open_url "$PR_URL"
            ;;
        0)
            exit "$EXIT_SUCCESS"
            ;;
    esac
}

# Cleanup after merge
cleanup_after_merge() {
    local auto_cleanup="${1:-}"

    if is_worktree; then
        get_current_worktree_info
        local main_repo
        main_repo=$(get_main_repo_root)

        if [[ "$auto_cleanup" == "auto" ]]; then
            # Auto cleanup
            cd "$main_repo" || exit 1
            echo "Cleaning up..."
            remove_worktree "$WT_PATH"
            echo "Deleted worktree: ${GREEN}$WT_NAME${RESET}"
            if delete_local_branch "$WT_BRANCH" 2>/dev/null; then
                echo "Deleted branch: $WT_BRANCH (local)"
            fi
            echo ""
            echo "Run: ${BOLD}cd $main_repo${RESET}"
        else
            # Ask about cleanup
            echo ""
            show_menu "Delete worktree and branch?" \
                "Yes (delete local worktree and remote branch)" \
                "Keep worktree and branch"

            case "$MENU_CHOICE" in
                1)
                    cd "$main_repo" || exit 1
                    remove_worktree "$WT_PATH"
                    echo "Deleted worktree: ${GREEN}$WT_NAME${RESET}"
                    if delete_local_branch "$WT_BRANCH" 2>/dev/null; then
                        echo "Deleted branch: $WT_BRANCH (local)"
                    fi
                    if branch_on_remote "$WT_BRANCH"; then
                        if delete_remote_branch "$WT_BRANCH" 2>/dev/null; then
                            echo "Deleted branch: $WT_BRANCH (remote)"
                        fi
                    fi
                    echo ""
                    echo "Run: ${BOLD}cd $main_repo${RESET}"
                    ;;
                2)
                    echo "Keeping worktree and branch."
                    ;;
                0)
                    exit "$EXIT_SUCCESS"
                    ;;
            esac
        fi
    fi
}

# Main merge flow
main_merge_flow() {
    local force_merge="${1:-}"
    local auto_cleanup="${2:-}"

    local current_branch
    current_branch=$(get_current_branch)

    # Get PR status
    local pr_json
    pr_json=$(get_pr_status) || {
        handle_no_pr "$current_branch"
        exit "$EXIT_GENERAL_ERROR"
    }

    parse_pr_status "$pr_json"
    display_pr_status

    # Check for issues
    if [[ "$PR_CHECKS_FAIL" -gt 0 && "$force_merge" != "force" ]]; then
        handle_checks_failing
        return
    fi

    if [[ "$PR_REVIEW" == "CHANGES_REQUESTED" ]]; then
        handle_not_approved
        return
    fi

    if [[ "$PR_MERGE_STATUS" == "DIRTY" ]]; then
        error "Cannot merge: PR has conflicts" \
            "The PR has merge conflicts that must be resolved" \
            "Resolve conflicts and push changes, then try again"
    fi

    # Merge menu
    if [[ "$auto_cleanup" == "auto" ]]; then
        merge_pr "delete"
        cleanup_after_merge "auto"
    else
        show_menu "Merge this PR?" \
            "Merge" \
            "Merge and delete worktree"

        case "$MENU_CHOICE" in
            1)
                merge_pr
                cleanup_after_merge
                ;;
            2)
                merge_pr "delete"
                cleanup_after_merge "auto"
                ;;
            0)
                echo "Cancelled."
                exit "$EXIT_SUCCESS"
                ;;
        esac
    fi
}

# ============================================================================
# Help
# ============================================================================

show_help() {
    cat <<EOF
Usage: wt-merge [OPTIONS]
       wt-merge help

Merges the PR for the current branch and optionally cleans up the worktree.

Requires: gh CLI (GitHub CLI) installed and authenticated

Options:
  --delete-worktree, -d    Auto-delete worktree and remote branch after merge
  --force, -f              Merge even if checks are failing (if repo allows)
  help                     Show this help message

Exit Codes:
  0    Success
  1    General error (no PR, gh not available)
  2    Invalid arguments
  3    Merge failed

Examples:
  wt-merge                 # Interactive merge
  wt-merge -d              # Merge and auto-cleanup worktree
  wt-merge -f              # Force merge despite failing checks

Environment:
  NO_COLOR                 Suppress colored output
EOF
}

# ============================================================================
# Main Entry Point
# ============================================================================

main() {
    local force_merge=""
    local auto_cleanup=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            help|--help|-h)
                show_help
                exit "$EXIT_SUCCESS"
                ;;
            --delete-worktree|-d)
                auto_cleanup="auto"
                shift
                ;;
            --force|-f)
                force_merge="force"
                shift
                ;;
            -*)
                error_with_code "$EXIT_INVALID_ARGS" \
                    "Unknown option: $1" \
                    "This option is not recognized" \
                    "Run 'wt-merge help' for usage information"
                ;;
            *)
                error_with_code "$EXIT_INVALID_ARGS" \
                    "Unexpected argument: $1" \
                    "wt-merge does not take positional arguments" \
                    "Run 'wt-merge help' for usage information"
                ;;
        esac
    done

    validate_git_repo
    require_gh_cli
    require_clean_worktree

    main_merge_flow "$force_merge" "$auto_cleanup"
}

main "$@"
